{% extends 'base.html' %}

{% block extra_head %}
<link rel="stylesheet" href="{{ url_for('static', path='css/chat_summary.css') }}">
<style>
/* Voice Chat UI Styles */
.blink {
  animation: blink-animation 1s infinite;
}

@keyframes blink-animation {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0.3; }
}

.voice-message {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  border-radius: 8px;
  background: rgba(0, 123, 255, 0.1);
  margin: 4px 0;
}

.voice-message.mine {
  background: rgba(255, 255, 255, 0.2);
}

.audio-waveform {
  flex: 1;
  height: 30px;
  background: linear-gradient(90deg, #007bff 0%, #0056b3 100%);
  border-radius: 15px;
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

.audio-waveform.mine {
  background: linear-gradient(90deg, #ffffff 0%, #f8f9fa 100%);
}

.play-voice-btn {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
}

.play-voice-btn:hover {
  transform: scale(1.1);
  border-color: rgba(255, 255, 255, 0.6);
  background: rgba(255, 255, 255, 0.2);
}

.play-voice-btn i {
  font-size: 14px;
  margin-left: 2px; /* Offset to center the play triangle */
}

.play-voice-btn.btn-light {
  background: rgba(0, 123, 255, 0.1);
  border-color: rgba(0, 123, 255, 0.3);
  color: #007bff;
}

.play-voice-btn.btn-light:hover {
  background: rgba(0, 123, 255, 0.2);
  border-color: rgba(0, 123, 255, 0.6);
}

.voice-duration {
  font-size: 0.75rem;
  color: #6c757d;
  margin-top: 2px;
}

.voice-transcription {
  background: rgba(0, 0, 0, 0.05);
  border-radius: 4px;
  padding: 4px 8px;
  margin-top: 4px;
  font-style: italic;
  font-size: 0.85rem;
}

#recording-indicator {
  position: absolute;
  right: 80px;
  background: rgba(255, 255, 255, 0.95);
  padding: 4px 8px;
  border-radius: 12px;
  border: 1px solid #dc3545;
}

/* Recording button styles */
#voice-record-btn {
  width: 42px;
  height: 42px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid #007bff;
  background: rgba(0, 123, 255, 0.1);
  transition: all 0.3s ease;
  position: relative;
}

#voice-record-btn:hover {
  transform: scale(1.05);
  background: rgba(0, 123, 255, 0.2);
  border-color: #0056b3;
  box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
}

#voice-record-btn i {
  font-size: 18px;
  color: #007bff;
  transition: color 0.3s ease;
}

#voice-record-btn:hover i {
  color: #0056b3;
}

/* Recording state styles */
#voice-record-btn.btn-danger {
  background: rgba(220, 53, 69, 0.2);
  border-color: #dc3545;
  animation: pulse-red 1.5s infinite;
}

#voice-record-btn.btn-danger i {
  color: #dc3545;
}

@keyframes pulse-red {
  0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
  70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
  100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
}

/* Voice status message styles */
#voice-status-message {
  border-left: 4px solid #ffc107;
  background-color: #fff3cd;
  border-color: #ffeaa7;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
}

#voice-status-message .fas {
  color: #856404;
}

.message-bubble {
  position: relative;
}

.language-badge {
  font-size: 0.65rem;
  padding: 2px 6px;
  border-radius: 8px;
  background: rgba(0, 0, 0, 0.1);
  color: #666;
}

.translation-note {
  font-size: 0.75rem;
  color: #6c757d;
  font-style: italic;
  margin-top: 2px;
}

/* Voice Call UI Styles */
.call-controls {
  display: flex;
  gap: 10px;
  align-items: center;
}

.call-button {
  background: rgba(40, 167, 69, 0.2);
  border: 1px solid rgba(40, 167, 69, 0.3);
  color: #28a745;
  border-radius: 25px;
  padding: 8px 16px;
  transition: all 0.3s ease;
}

.call-button:hover {
  background: rgba(40, 167, 69, 0.3);
  color: #28a745;
  transform: translateY(-1px);
}

.call-button.active {
  background: rgba(40, 167, 69, 0.9);
  color: white;
}

.call-status {
  background: rgba(40, 167, 69, 0.1);
  border: 1px solid rgba(40, 167, 69, 0.2);
  border-radius: 20px;
  padding: 5px 12px;
  font-size: 0.85rem;
  color: #28a745;
}

.call-indicator {
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}
</style>
{% endblock %}

{% block content %}
<div class="row">
  <div class="col-lg-8 mx-auto">
    <div class="card shadow-sm">
      <div class="card-header d-flex justify-content-between align-items-center">
        <div class="d-flex align-items-center gap-2">
          <strong>{{ remote_user.full_name or remote_user.email }}</strong>
          <small id="user-status" class="badge bg-secondary">
            <i class="fas fa-circle me-1"></i>Checking...
          </small>
        </div>
        <div class="d-flex align-items-center gap-2">
          <select id="language-select" class="form-select form-select-sm" style="width: auto;">
            <option value="en" {{ 'selected' if current_user.preferred_language == 'en' else '' }}>English</option>
            <option value="fr" {{ 'selected' if current_user.preferred_language == 'fr' else '' }}>Français</option>
            <option value="ar" {{ 'selected' if current_user.preferred_language == 'ar' else '' }}>العربية</option>
          </select>
          
          <!-- Chat History Download Button -->
          <button id="download-chat-btn" class="btn btn-sm btn-outline-success" title="Download Chat History as CSV">
            <i class="fas fa-download"></i> CSV
          </button>
          
          <!-- NEW: Chat Summary Buttons -->
          <button id="generateSummaryBtn" class="btn btn-sm btn-outline-primary" title="Generate AI Summary">
            <i class="bi bi-lightbulb"></i> <span class="d-none d-md-inline">Summary</span>
          </button>
          
          <button id="downloadSummaryBtn" class="btn btn-sm btn-outline-info" style="display: none;" title="Download Summary">
            <i class="bi bi-download"></i> <span class="d-none d-md-inline">Download</span>
          </button>
          
          <!-- Voice Call Controls -->
          <div class="call-controls">
            <button id="voice-call-btn" class="btn call-button" title="Start Voice Call">
              <i class="fas fa-phone"></i> <span id="callBtnText">Call</span>
            </button>
            <button id="cleanup-calls-btn" class="btn btn-sm btn-outline-warning ml-2" title="Reset Call State" style="display: inline-block;">
              <i class="fas fa-broom"></i> Reset
            </button>
            <div id="call-status" class="call-status d-none">
              <i class="fas fa-phone call-indicator"></i> <span id="callStatusText">Ready for voice call</span>
            </div>
          </div>
          
          <a class="btn btn-sm btn-outline-secondary" href="/">Back</a>
        </div>
      </div>
      <div class="card-body p-0 d-flex flex-column" style="height:60vh;">
        <div id="messages" class="flex-grow-1 overflow-auto p-3 small bg-light"></div>
        <form id="chat-form" class="border-top p-2 d-flex gap-2 align-items-center">
          <input id="message-input" autocomplete="off" class="form-control" placeholder="Type a message" />
          
          <!-- Voice recording button -->
          <button id="voice-record-btn" type="button" class="btn btn-outline-primary" title="Record Voice Message">
            <i class="fas fa-microphone"></i>
          </button>
          
          <!-- Voice features info button (shown when voice is unavailable) -->
          <button id="voice-info-btn" type="button" class="btn btn-outline-info" title="Voice Features Info" style="display: none;" data-bs-toggle="modal" data-bs-target="#voice-info-modal">
            <i class="fas fa-info-circle"></i>
          </button>
          
          <!-- Recording indicator -->
          <div id="recording-indicator" class="d-none align-items-center text-danger">
            <i class="fas fa-circle blink me-1"></i>
            <small>Recording...</small>
          </div>
          
          <button class="btn btn-primary" type="submit">Send</button>
        </form>
      </div>
    </div>
  </div>
</div>

<!-- Voice Features Info Modal -->
<div class="modal fade" id="voice-info-modal" tabindex="-1" aria-labelledby="voice-info-modal-label" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="voice-info-modal-label">
          <i class="fas fa-microphone text-primary"></i> Voice Features
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-info">
          <h6><i class="fas fa-info-circle"></i> Requirements for Voice Features</h6>
          <p>Voice recording and voice calls require:</p>
          <ul>
            <li><strong>Secure Connection (HTTPS)</strong> - Required for remote access</li>
            <li><strong>Microphone Permission</strong> - Allow browser access to your microphone</li>
            <li><strong>Modern Browser</strong> - Chrome, Firefox, Safari, or Edge</li>
          </ul>
        </div>
        
        <div id="voice-diagnostics">
          <!-- Dynamically populated with diagnostic info -->
        </div>
        
        <div class="mt-3">
          <h6><i class="fas fa-tools"></i> Troubleshooting</h6>
          <div class="accordion" id="troubleshooting-accordion">
            <div class="accordion-item">
              <h2 class="accordion-header" id="https-heading">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#https-collapse">
                  🔒 HTTPS Issues
                </button>
              </h2>
              <div id="https-collapse" class="accordion-collapse collapse" data-bs-parent="#troubleshooting-accordion">
                <div class="accordion-body">
                  <p>If you're accessing the site via HTTP, voice features won't work on remote networks.</p>
                  <p><strong>Solutions:</strong></p>
                  <ul>
                    <li>Access the site using HTTPS instead</li>
                    <li>Use localhost for development</li>
                    <li>Set up SSL certificates on the server</li>
                  </ul>
                </div>
              </div>
            </div>
            
            <div class="accordion-item">
              <h2 class="accordion-header" id="permission-heading">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#permission-collapse">
                  🎤 Microphone Permissions
                </button>
              </h2>
              <div id="permission-collapse" class="accordion-collapse collapse" data-bs-parent="#troubleshooting-accordion">
                <div class="accordion-body">
                  <p>If microphone access is denied:</p>
                  <ul>
                    <li>Click the microphone icon in your browser's address bar</li>
                    <li>Select "Allow" for microphone access</li>
                    <li>Refresh the page after granting permission</li>
                    <li>Check if other apps are using the microphone</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-primary" onclick="checkVoiceRecordingSupport()">
          <i class="fas fa-redo"></i> Test Again
        </button>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const token = JSON.parse('{{ token|tojson|safe }}');
  const otherUserId = JSON.parse('{{ remote_user.id|tojson|safe }}');
  const currentUserId = JSON.parse('{{ current_user.id|tojson|safe }}');
  const currentUserName = '{{ current_user.full_name or current_user.email }}';
  const otherUserName = '{{ remote_user.full_name or remote_user.email }}';
  const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
  const wsUrl = `${wsProtocol}://${location.host}/ws/chat/${otherUserId}?token=${encodeURIComponent(token)}`;
  const socket = new WebSocket(wsUrl);
  const box = document.getElementById('messages');
  
  // Initialize user language preference from the selected dropdown value
  let userLanguage = document.getElementById('language-select').value || '{{ current_user.preferred_language }}' || 'en';
  
  let typingTimeout; // For typing indicator timing
  let typingIndicatorElement; // Track typing indicator
  let onlineStatusCheckInterval; // For periodic online status checks

  // Voice recording variables
  let mediaRecorder;
  let audioChunks = [];
  let isRecording = false;
  let audioStream;

  // Initialize voice recording functionality
  function initializeVoiceRecording() {
    const recordBtn = document.getElementById('voice-record-btn');
    const recordingIndicator = document.getElementById('recording-indicator');
    
    recordBtn.addEventListener('click', function() {
      if (!isRecording) {
        startVoiceRecording();
      } else {
        stopVoiceRecording();
      }
    });
  }

  // Start voice recording
  async function startVoiceRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          sampleRate: 44100
        } 
      });
      
      audioStream = stream;
      audioChunks = [];
      
      // Create MediaRecorder
      mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'audio/webm;codecs=opus'
      });
      
      mediaRecorder.ondataavailable = function(event) {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      
      mediaRecorder.onstop = function() {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        sendVoiceMessage(audioBlob);
        
        // Stop all tracks
        audioStream.getTracks().forEach(track => track.stop());
      };
      
      // Start recording
      mediaRecorder.start();
      isRecording = true;
      
      // Update UI
      updateRecordingUI(true);
      
    } catch (error) {
      console.error('Error accessing microphone:', error);
      alert('Could not access microphone. Please check permissions.');
    }
  }

  // Stop voice recording
  function stopVoiceRecording() {
    if (mediaRecorder && isRecording) {
      mediaRecorder.stop();
      isRecording = false;
      updateRecordingUI(false);
    }
  }

  // Update recording UI
  function updateRecordingUI(recording) {
    const recordBtn = document.getElementById('voice-record-btn');
    const recordingIndicator = document.getElementById('recording-indicator');
    
    if (recording) {
      recordBtn.innerHTML = '<i class="fas fa-stop"></i>';
      recordBtn.className = 'btn btn-danger';
      recordingIndicator.classList.remove('d-none');
      recordingIndicator.classList.add('d-flex');
    } else {
      recordBtn.innerHTML = '<i class="fas fa-microphone"></i>';
      recordBtn.className = 'btn btn-outline-primary';
      recordingIndicator.classList.add('d-none');
      recordingIndicator.classList.remove('d-flex');
    }
  }

  // Send voice message to server
  async function sendVoiceMessage(audioBlob) {
    try {
      const formData = new FormData();
      formData.append('audio', audioBlob, 'voice_message.webm');
      formData.append('language', document.getElementById('language-select').value);
      formData.append('recipient_id', otherUserId);
      
      const response = await fetch('/api/voice/upload-message', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        },
        body: formData
      });
      
      if (!response.ok) {
        throw new Error('Failed to send voice message');
      }
      
      const result = await response.json();
      
      if (result.success) {
        console.log('Voice message sent:', result);
        // Voice message will be received via WebSocket
      } else {
        throw new Error(result.error || 'Unknown error');
      }
      
    } catch (error) {
      console.error('Error sending voice message:', error);
      addSystem('[Voice message failed to send: ' + error.message + ']');
    }
  }

  // Online status functions
  function updateUserOnlineStatus(isOnline) {
    const statusElement = document.getElementById('user-status');
    if (statusElement) {
      if (isOnline) {
        statusElement.innerHTML = '<i class="fas fa-circle me-1"></i>Online';
        statusElement.className = 'badge bg-success';
      } else {
        statusElement.innerHTML = '<i class="fas fa-circle me-1"></i>Offline';
        statusElement.className = 'badge bg-secondary';
      }
    }
  }

  function checkOnlineStatus() {
    if (!token) return;
    
    fetch('/api/chat/online-users/global', {
      headers: { 'Authorization': 'Bearer ' + token }
    })
    .then(r => r.ok ? r.json() : { online_users: [] })
    .then(data => {
      const isOnline = data.online_users.includes(otherUserId);
      updateUserOnlineStatus(isOnline);
    })
    .catch(() => {
      // Show offline on error
      updateUserOnlineStatus(false);
    });
  }

  function addSystem(text){
    const d=document.createElement('div');
    d.className='text-muted small mb-1';
    d.textContent=text; box.appendChild(d); box.scrollTop=box.scrollHeight;
  }

  function getDisplayText(originalText, originalLang, translationsCache) {
    // Debug logging
    console.log('getDisplayText called:', {
      originalText: originalText,
      originalLang: originalLang,
      userLanguage: userLanguage,
      translationsCache: translationsCache
    });
    
    // If user's language matches original language, return original
    if (userLanguage === originalLang) {
      console.log('Language matches original, returning original text');
      return { text: originalText, isTranslated: false };
    }
    
    // If translation exists, return it
    if (translationsCache && translationsCache[userLanguage]) {
      console.log('Translation found for', userLanguage, ':', translationsCache[userLanguage]);
      return { text: translationsCache[userLanguage], isTranslated: true };
    }
    
    // Return original as fallback
    console.log('No translation found, returning original text');
    return { text: originalText, isTranslated: false };
  }

  function addMessage(senderId, senderEmail, originalText, originalLang = 'en', translationsCache = {}, timestamp = null){
    const mine = Number(senderId) === Number(currentUserId);
    const wrap=document.createElement('div');
    wrap.className='mb-1 d-flex '+(mine?'justify-content-end':'justify-content-start');
    const bubble=document.createElement('div');
    bubble.className='px-2 py-1 rounded '+(mine?'bg-primary text-white':'bg-white border');
    bubble.style.maxWidth='70%';
    const label = mine ? 'You' : senderEmail;
    
    // Format timestamp
    let timeStr = '';
    if (timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const isToday = date.toDateString() === now.toDateString();
      
      if (isToday) {
        // Show only time for today's messages
        timeStr = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      } else {
        // Show date and time for older messages
        timeStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      }
    }
    
    // Get appropriate text to display
    const displayData = getDisplayText(originalText, originalLang, translationsCache);
    const displayText = displayData.text;
    
    // Debug message display
    console.log('Displaying message:', {
      sender: senderEmail,
      originalText: originalText,
      displayText: displayText,
      isTranslated: displayData.isTranslated,
      currentUserLanguage: userLanguage
    });
    
    // Create message content with timestamp
    let messageContent = '<div><strong class="me-1">'+label+':</strong>'+displayText;
    
    // Add timestamp
    if (timeStr) {
      messageContent += '<br><small class="text-muted opacity-75"><i class="fas fa-clock me-1"></i>' + timeStr + '</small>';
    }
    
    // Add language indicator and original text if translated
    if (displayData.isTranslated) {
      messageContent += `<br><small class="text-muted opacity-75">Translated from ${originalLang.toUpperCase()}: ${originalText}</small>`;
    } else if (originalLang !== 'en') {
      messageContent += `<br><small class="text-muted opacity-75">${originalLang.toUpperCase()}</small>`;
    }
    
    messageContent += '</div>';
    
    bubble.innerHTML = messageContent;
    wrap.appendChild(bubble); box.appendChild(wrap); box.scrollTop=box.scrollHeight;
  }

  // Add voice message to chat
  function addVoiceMessage(senderId, senderEmail, originalText, audioUrls = {}, originalLang = 'en', translationsCache = {}, timestamp = null, audioDuration = 0) {
    const mine = Number(senderId) === Number(currentUserId);
    const wrap = document.createElement('div');
    wrap.className = 'mb-1 d-flex ' + (mine ? 'justify-content-end' : 'justify-content-start');
    
    const bubble = document.createElement('div');
    bubble.className = 'px-2 py-1 rounded message-bubble ' + (mine ? 'bg-primary text-white' : 'bg-white border');
    bubble.style.maxWidth = '70%';
    
    const label = mine ? 'You' : senderEmail;
    
    // Format timestamp
    let timeStr = '';
    if (timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const isToday = date.toDateString() === now.toDateString();
      
      if (isToday) {
        timeStr = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      } else {
        timeStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      }
    }
    
    // Get appropriate text and audio URL to display
    const displayData = getDisplayText(originalText, originalLang, translationsCache);
    const displayText = displayData.text;
    const audioUrl = getAudioUrlForLanguage(audioUrls, userLanguage, originalLang);
    
    // Format duration
    const durationStr = formatDuration(audioDuration);
    
    // Create voice message content
    let messageContent = `
      <div>
        <strong class="me-1">${label}:</strong>
        <span class="language-badge">${originalLang.toUpperCase()}</span>
        <div class="voice-message ${mine ? 'mine' : ''} mt-2">
          <button class="play-voice-btn btn ${mine ? 'btn-light' : 'btn-primary'} btn-sm" data-audio-url="${audioUrl}">
            <i class="fas fa-play"></i>
          </button>
          <div class="audio-waveform ${mine ? 'mine' : ''}">
            <small class="${mine ? 'text-primary' : 'text-white'}">
              <i class="fas fa-volume-up me-1"></i>Voice Message
            </small>
          </div>
          <small class="voice-duration">${durationStr}</small>
        </div>
        <div class="voice-transcription">
          <small>"${displayText}"</small>
        </div>
    `;
    
    // Add timestamp
    if (timeStr) {
      messageContent += `<br><small class="text-muted opacity-75"><i class="fas fa-clock me-1"></i>${timeStr}</small>`;
    }
    
    // Add translation note
    if (displayData.isTranslated) {
      messageContent += `<div class="translation-note">Translated from ${originalLang.toUpperCase()}: "${originalText}"</div>`;
    }
    
    messageContent += '</div>';
    bubble.innerHTML = messageContent;
    
    // Add click event for play button
    const playBtn = bubble.querySelector('.play-voice-btn');
    playBtn.addEventListener('click', function() {
      playVoiceMessage(audioUrl, playBtn);
    });
    
    wrap.appendChild(bubble);
    box.appendChild(wrap);
    box.scrollTop = box.scrollHeight;
  }

  // Get audio URL for user's preferred language
  function getAudioUrlForLanguage(audioUrls, userLang, originalLang) {
    if (!audioUrls) return null;
    
    // Try user's preferred language first
    if (audioUrls[userLang]) {
      return audioUrls[userLang];
    }
    
    // Fallback to original language
    if (audioUrls[originalLang]) {
      return audioUrls[originalLang];
    }
    
    // Return any available audio
    const availableUrls = Object.values(audioUrls);
    return availableUrls.length > 0 ? availableUrls[0] : null;
  }

  // Format duration in mm:ss
  function formatDuration(seconds) {
    if (!seconds || seconds <= 0) return '0:00';
    
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  }

  // Play voice message
  function playVoiceMessage(audioUrl, playBtn) {
    if (!audioUrl) {
      console.error('No audio URL provided');
      return;
    }
    
    const audio = new Audio(audioUrl);
    const icon = playBtn.querySelector('i');
    
    // Update button to show playing state
    icon.className = 'fas fa-pause';
    playBtn.disabled = true;
    
    audio.play().catch(error => {
      console.error('Error playing audio:', error);
      icon.className = 'fas fa-play';
      playBtn.disabled = false;
    });
    
    audio.onended = function() {
      icon.className = 'fas fa-play';
      playBtn.disabled = false;
    };
    
    audio.onerror = function() {
      icon.className = 'fas fa-play';
      playBtn.disabled = false;
      console.error('Error loading audio file');
    };
    
    // Allow pausing
    playBtn.onclick = function() {
      if (!audio.paused) {
        audio.pause();
        icon.className = 'fas fa-play';
        playBtn.disabled = false;
      }
    };
  }

  function showTypingIndicator() {
    // Remove existing typing indicator
    hideTypingIndicator();
    
    // Create new typing indicator
    typingIndicatorElement = document.createElement('div');
    typingIndicatorElement.className = 'mb-1 d-flex justify-content-start';
    typingIndicatorElement.id = 'typing-indicator';
    
    const bubble = document.createElement('div');
    bubble.className = 'px-2 py-1 rounded bg-light border text-muted small';
    bubble.style.maxWidth = '70%';
    bubble.innerHTML = `<em>${otherUserName} is typing...</em>`;
    
    typingIndicatorElement.appendChild(bubble);
    box.appendChild(typingIndicatorElement);
    box.scrollTop = box.scrollHeight;
  }

  function hideTypingIndicator() {
    if (typingIndicatorElement) {
      typingIndicatorElement.remove();
      typingIndicatorElement = null;
    }
  }

  function sendTypingIndicator(isTyping) {
    const typingData = {
      type: "typing",
      typing: isTyping
    };
    socket.send(JSON.stringify(typingData));
  }

  socket.onopen=()=>{
    addSystem('[Connected]');
    // Check online status when WebSocket connects
    checkOnlineStatus();
  };
  socket.onclose=()=>{
    addSystem('[Disconnected]');
    // Show offline when WebSocket disconnects
    updateUserOnlineStatus(false);
  };
  socket.onmessage=(ev)=>{
    try {
      const data = JSON.parse(ev.data);
      if(data.system){ addSystem('['+data.event+'] '+(data.user.email || data.user.id)); return; }
      
      // Handle typing indicators
      if(data.type === 'typing_update') {
        const typingUsers = data.typing_user_ids || [];
        const isOtherUserTyping = typingUsers.includes(otherUserId);
        
        if (isOtherUserTyping) {
          showTypingIndicator();
        } else {
          hideTypingIndicator();
        }
        return;
      }
      
      // Handle online status updates
      if(data.type === 'online_users_update') {
        // Update online status indicator in chat header
        const onlineUsers = data.online_user_ids || [];
        const isOtherUserOnline = onlineUsers.includes(otherUserId);
        updateUserOnlineStatus(isOtherUserOnline);
        return;
      }
      
      // Handle regular messages
      if(!data.sender){ addSystem('[Missing sender]'); return; }
      
      // Hide typing indicator when message arrives
      hideTypingIndicator();
      
      // Check if it's a voice message
      if (data.message_type === 'voice' && data.audio_urls) {
        addVoiceMessage(
          data.sender.id,
          data.sender.name || data.sender.email,
          data.original_text,
          data.audio_urls || {},
          data.original_language || 'en',
          data.translations_cache || {},
          data.timestamp,
          data.audio_duration || 0
        );
      } else {
        // Regular text message
        addMessage(
          data.sender.id, 
          data.sender.name || data.sender.email, 
          data.original_text,
          data.original_language || 'en',
          data.translations_cache || {},
          data.timestamp
        );
      }
    } catch(err){ console.error('WS error', err, ev.data); addSystem('[Bad message]'); }
  };

  document.getElementById('chat-form').addEventListener('submit', e=>{
    e.preventDefault();
    const inp=document.getElementById('message-input');
    const inputLang=document.getElementById('language-select').value;
    const t=inp.value.trim();
    if(!t) return; 
    
    // Send message with language information
    const messageData = {
      text: t,
      language: inputLang,
      auto_translate: true
    };
    
    socket.send(JSON.stringify(messageData)); 
    inp.value='';
  });

  function loadChatHistory() {
    // Clear existing messages
    box.innerHTML = '';
    
    fetch(`/api/chat/history/${otherUserId}`, {headers:{'Authorization':`Bearer ${token}`}})
      .then(r=>r.ok?r.json():[])
      .then(rows=>{ 
        rows.forEach(m=> {
          // Check if it's a voice message
          if (m.message_type === 'voice' && m.audio_urls) {
            addVoiceMessage(
              m.sender_id,
              m.sender_id === currentUserId ? currentUserName : otherUserName,
              m.original_text,
              m.audio_urls || {},
              m.original_language || 'en',
              m.translations_cache || {},
              m.timestamp,
              m.audio_duration || 0
            );
          } else {
            // Regular text message
            addMessage(
              m.sender_id, 
              m.sender_id === currentUserId ? currentUserName : otherUserName, 
              m.original_text,
              m.original_language || 'en',
              m.translations_cache || {},
              m.timestamp
            );
          }
        }); 
      })
      .catch(()=>{});
  }

  // Load initial chat history
  loadChatHistory();

  // Add typing indicator functionality to message input
  const messageInput = document.getElementById('message-input');
  let isTyping = false;
  
  messageInput.addEventListener('input', function() {
    if (!isTyping) {
      isTyping = true;
      sendTypingIndicator(true);
    }
    
    // Clear previous timeout
    clearTimeout(typingTimeout);
    
    // Stop typing after 2 seconds of inactivity
    typingTimeout = setTimeout(() => {
      isTyping = false;
      sendTypingIndicator(false);
    }, 2000);
  });

  messageInput.addEventListener('keydown', function(e) {
    // Stop typing when user presses Enter to send message
    if (e.key === 'Enter') {
      clearTimeout(typingTimeout);
      if (isTyping) {
        isTyping = false;
        sendTypingIndicator(false);
      }
    }
  });

  // Initialize online status checking (initial load only)
  // Cache buster: v2.1 - Removed setInterval polling for performance optimization  
  checkOnlineStatus(); // Check immediately on load
  // Removed setInterval - WebSocket handles real-time online status updates
  
  // Note: onlineStatusCheckInterval variable kept for compatibility but not used

  // Save user's language preference when changed (input language dropdown)
  // const languageSelect = document.getElementById('input-language');
  const displayLanguageSelect = document.getElementById('language-select');
  displayLanguageSelect.addEventListener('change', function() {
    const selectedLanguage = this.value;
    
    // Update current language for message display
    userLanguage = selectedLanguage;
    
    // Reload chat history with new language preference
    loadChatHistory();
    
    // Save preference to backend
    fetch('/users/update-language', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ preferred_language: selectedLanguage })
    }).catch(error => {
      console.log('Language preference save failed:', error);
      // Don't show error to user, just log it
    });
  });

  // Save user's language preference when changed (display language dropdown)
  // const displayLanguageSelect = document.getElementById('language-select');
  // displayLanguageSelect.addEventListener('change', function() {
  //   const selectedLanguage = this.value;
    
  //   // Update current language for message display
  //   userLanguage = selectedLanguage;
    
  //   // Reload chat history with new language preference
  //   loadChatHistory();
    
  //   // Save preference to backend
  //   fetch('/users/update-language', {
  //     method: 'POST',
  //     headers: {
  //       'Content-Type': 'application/json',
  //       'Authorization': `Bearer ${token}`
  //     },
  //     body: JSON.stringify({ preferred_language: selectedLanguage })
  //   }).catch(error => {
  //     console.log('Language preference save failed:', error);
  //     // Don't show error to user, just log it
  //   });
  // });

  // Initialize voice recording functionality
  initializeVoiceRecording();

  // Initialize voice call functionality
  let voiceCallSocket = null;
  let isCallActive = false;
  let callWindow = null;

  function initializeVoiceCall() {
    const voiceCallBtn = document.getElementById('voice-call-btn');
    const cleanupBtn = document.getElementById('cleanup-calls-btn');
    
    if (voiceCallBtn) {
      voiceCallBtn.addEventListener('click', function() {
        toggleVoiceCall();
      });
    }
    
    if (cleanupBtn) {
      cleanupBtn.addEventListener('click', function() {
        forceCleanupCalls();
      });
    }

    // Initialize voice call WebSocket
    if (!voiceCallSocket) {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      voiceCallSocket = new WebSocket(`${protocol}//${window.location.host}/api/voice-call/ws?token=${token}`);
      
      voiceCallSocket.onopen = () => {
        console.log('Voice call WebSocket connected');
        updateCallStatus('Ready for voice call');
        
        // Auto-cleanup stale calls on connection
        setTimeout(() => {
          console.log('🧹 Auto-checking for stale calls...');
          checkAndCleanupStaleCalls();
        }, 1000);
      };
      
      voiceCallSocket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleVoiceCallMessage(data);
      };
      
      voiceCallSocket.onclose = () => {
        console.log('Voice call WebSocket disconnected');
        updateCallStatus('Voice call disconnected');
      };
      
      voiceCallSocket.onerror = (error) => {
        console.error('Voice call WebSocket error:', error);
        updateCallStatus('Voice call error');
      };
    }
  }

  // Handle voice call messages
  function handleVoiceCallMessage(data) {
    console.log('📞 Voice call message received:', data);
    
    switch (data.type) {
      case 'call_initiated':
        console.log('✅ Call initiated successfully');
        updateCallStatus('Call initiated, opening window...', true);
        openVoiceCallWindow(data.call_id);
        break;
      
      case 'incoming_call':
        console.log('📞 Incoming call from:', data.caller_name);
        updateCallStatus(`Incoming call from ${data.caller_name || 'User'}`);
        
        // Show more user-friendly notification
        const accept = confirm(`📞 Incoming call from ${data.caller_name || 'User'}\n\nWould you like to accept this call?`);
        if (accept) {
          acceptCall(data.call_id);
        } else {
          declineCall(data.call_id);
        }
        break;
      
      case 'call_answered':
        console.log('✅ Call answered successfully');
        updateCallStatus('Call answered - connecting...', true);
        
        // Update button state for caller
        const btn = document.getElementById('voice-call-btn');
        const btnText = document.getElementById('callBtnText');
        btn.className = 'btn call-button active';
        btnText.textContent = 'In Call';
        isCallActive = true;
        break;
      
      case 'call_declined':
        console.log('❌ Call was declined');
        updateCallStatus('Call declined');
        alert('The call was declined by the other user.');
        resetCallButton();
        break;
      
      case 'call_ended':
        updateCallStatus('Call ended');
        resetCallButton();
        if (callWindow && !callWindow.closed) {
          callWindow.close();
        }
        break;
      
      default:
        console.log('Unknown voice call message type:', data.type);
    }
  }

  // Toggle voice call
  function toggleVoiceCall() {
    if (isCallActive) {
      endVoiceCall();
    } else {
      initiateVoiceCall();
    }
  }

  // Initiate voice call
  async function initiateVoiceCall() {
    try {
      console.log('🚀 Initiating voice call to user:', otherUserId);
      
      // Update button state
      const voiceCallBtn = document.getElementById('voice-call-btn');
      const btnText = document.getElementById('callBtnText');
      voiceCallBtn.disabled = true;
      btnText.textContent = 'Calling...';
      
      updateCallStatus('Initiating call...');
      
      // Send call initiation request
      const response = await fetch('/api/voice-call/initiate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          callee_id: otherUserId,
          call_type: 'voice',
          message: 'Voice call request'
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || 'Failed to initiate call');
      }
      
      const callData = await response.json();
      console.log('✅ Call initiated:', callData);
      
      // WebSocket will handle the call_initiated message
      
    } catch (error) {
      console.error('❌ Failed to initiate voice call:', error);
      alert('Failed to start voice call: ' + error.message);
      resetCallButton();
      
      // Show cleanup button for call state issues
      if (error.message.includes('already in a call') || error.message.includes('busy')) {
        document.getElementById('cleanup-calls-btn').style.display = 'inline-block';
      }
    }
  }

  // End voice call
  function endVoiceCall() {
    if (voiceCallSocket && voiceCallSocket.readyState === WebSocket.OPEN) {
      voiceCallSocket.send(JSON.stringify({
        type: 'end_call'
      }));
    }
    
    resetCallButton();
    updateCallStatus('Call ended');
    
    // Close call window if open
    if (callWindow && !callWindow.closed) {
      callWindow.close();
    }
  }

  // Accept incoming call
  async function acceptCall(callId) {
    try {
      console.log('📞 Accepting call:', callId);
      updateCallStatus('Accepting call...');
      
      const response = await fetch(`/api/voice-call/answer/${callId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          sdp_answer: null // Will be set up in the call window
        })
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('✅ Call accepted:', result);
        updateCallStatus('Call accepted, opening window...');
        
        // Update button state
        const btn = document.getElementById('voice-call-btn');
        const btnText = document.getElementById('callBtnText');
        btn.className = 'btn call-button active';
        btnText.textContent = 'In Call';
        isCallActive = true;
        
        // Open call window
        openVoiceCallWindow(callId);
      } else {
        const errorData = await response.json();
        throw new Error(errorData.detail || 'Failed to accept call');
      }
    } catch (error) {
      console.error('❌ Failed to accept call:', error);
      updateCallStatus('Failed to accept call');
      alert('Failed to accept call: ' + error.message);
      resetCallButton();
    }
  }

  // Decline incoming call
  async function declineCall(callId) {
    try {
      await fetch(`/api/voice-call/decline/${callId}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
    } catch (error) {
      console.error('Failed to decline call:', error);
    }
  }

  // Clear call cache
  function clearCallCache() {
    try {
      // Clear browser cache related to voice calls
      if ('caches' in window) {
        caches.keys().then(names => {
          names.forEach(name => {
            if (name.includes('call') || name.includes('voice')) {
              caches.delete(name);
            }
          });
        });
      }
      
      // Clear session storage
      sessionStorage.removeItem('currentCall');
      sessionStorage.removeItem('callState');
      
      // Clear local storage call-related items
      Object.keys(localStorage).forEach(key => {
        if (key.includes('call') || key.includes('voice')) {
          localStorage.removeItem(key);
        }
      });
      
      console.log('📞 Call cache cleared');
    } catch (error) {
      console.log('Cache clearing failed:', error);
    }
  }

  // Force cleanup user's call state (for debugging)
  async function forceCleanupCalls() {
    try {
      console.log('🧹 Force cleaning up call state...');
      updateCallStatus('Cleaning up calls...');
      
      const response = await fetch('/api/voice-call/force-cleanup', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('✅ Force cleanup completed:', result);
        alert(`Cleanup completed: ${result.message}`);
        
        // Reset UI state
        resetCallButton();
        updateCallStatus('Ready for voice call');
        clearCallCache();
        
        // Hide cleanup button after successful cleanup
        document.getElementById('cleanup-calls-btn').style.display = 'none';
      } else {
        const errorData = await response.json();
        throw new Error(errorData.detail || 'Failed to cleanup calls');
      }
    } catch (error) {
      console.error('❌ Failed to cleanup calls:', error);
      alert('Failed to cleanup calls: ' + error.message);
      updateCallStatus('Cleanup failed');
    }
  }

  // Auto-check and cleanup stale calls (silent)
  async function checkAndCleanupStaleCalls() {
    try {
      console.log('🔍 Checking for stale calls...');
      
      const response = await fetch('/api/voice-call/force-cleanup', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (response.ok) {
        const result = await response.json();
        if (result.message && !result.message.includes('0 active calls')) {
          console.log('🧹 Auto-cleanup completed:', result.message);
          resetCallButton();
          clearCallCache();
        }
      }
    } catch (error) {
      console.log('Auto-cleanup check failed (non-critical):', error);
    }
  }

  // Reset call button
  function resetCallButton() {
    const btn = document.getElementById('voice-call-btn');
    const btnText = document.getElementById('callBtnText');
    btn.className = 'btn call-button';
    btnText.textContent = 'Call';
    btn.disabled = false;
    isCallActive = false;
    
    // Clear call cache when resetting
    clearCallCache();
  }

  // Update call status
  function updateCallStatus(message, inCall = false) {
    const statusEl = document.getElementById('call-status');
    const textEl = document.getElementById('callStatusText');
    
    if (statusEl && textEl) {
      if (inCall || message === 'Ready for voice call') {
        statusEl.classList.remove('d-none');
      } else if (message === 'Call ended' || message === 'Call declined') {
        setTimeout(() => {
          statusEl.classList.add('d-none');
        }, 3000);
      }
      textEl.textContent = message;
    }
  }

  // Open voice call window
  function openVoiceCallWindow(callId) {
    try {
      console.log('📞 Opening voice call window for call:', callId);
      
      // Clear any existing call cache before opening new call
      clearCallCache();
      
      // Include token in URL parameters for authentication
      const tokenParam = token ? `&token=${encodeURIComponent(token)}` : '';
      const windowFeatures = 'width=1200,height=800,scrollbars=yes,resizable=yes,status=yes,location=yes,toolbar=no,menubar=no';
      callWindow = window.open(`/voice-call?call_id=${callId}&t=${Date.now()}${tokenParam}`, 'voiceCall', windowFeatures);
      
      if (!callWindow) {
        throw new Error('Failed to open call window. Please allow popups for this site.');
      }

      callWindow.focus();
      isCallActive = true;
      updateCallStatus('Voice call window opened', true);
      
      // Update button state
      const btn = document.getElementById('voice-call-btn');
      const btnText = document.getElementById('callBtnText');
      btn.className = 'btn call-button active';
      btnText.textContent = 'End Call';
      
      // Monitor window close
      const checkClosed = setInterval(() => {
        if (callWindow.closed) {
          console.log('📞 Call window was closed');
          clearInterval(checkClosed);
          endVoiceCall();
        }
      }, 1000);
      
      console.log('✅ Voice call window opened successfully');
      
    } catch (error) {
      console.error('❌ Failed to open voice call window:', error);
      alert('Failed to open voice call window: ' + error.message);
      resetCallButton();
    }
  }

  // Initialize voice call functionality
  initializeVoiceCall();

  // Check browser compatibility and security context for voice recording
  async function checkVoiceRecordingSupport() {
    const recordBtn = document.getElementById('voice-record-btn');
    const infoBtn = document.getElementById('voice-info-btn');
    const diagnostics = document.getElementById('voice-diagnostics');
    
    // Initialize diagnostic info
    let diagnosticInfo = {
      browser: navigator.userAgent,
      secureContext: window.isSecureContext,
      mediaDevices: !!navigator.mediaDevices,
      getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
      hostname: window.location.hostname,
      protocol: window.location.protocol
    };
    
    // Update diagnostics display
    if (diagnostics) {
      diagnostics.innerHTML = `
        <div class="card">
          <div class="card-body">
            <h6 class="card-title">System Information</h6>
            <div class="row">
              <div class="col-sm-6">
                <small><strong>Protocol:</strong> ${diagnosticInfo.protocol}</small><br>
                <small><strong>Hostname:</strong> ${diagnosticInfo.hostname}</small><br>
                <small><strong>Secure Context:</strong> ${diagnosticInfo.secureContext ? '✅ Yes' : '❌ No'}</small>
              </div>
              <div class="col-sm-6">
                <small><strong>MediaDevices API:</strong> ${diagnosticInfo.mediaDevices ? '✅ Available' : '❌ Not Available'}</small><br>
                <small><strong>getUserMedia:</strong> ${diagnosticInfo.getUserMedia ? '✅ Available' : '❌ Not Available'}</small>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Check MediaDevices API availability but don't immediately hide the button
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      // Browser doesn't support MediaDevices API - show info but still allow users to try
      console.warn('Voice recording may not be supported: MediaDevices API not fully available');
      
      // Only hide if we're sure it won't work (very old browsers)
      if (!navigator.mediaDevices) {
        recordBtn.style.display = 'none';
        infoBtn.style.display = 'inline-block';
        showVoiceUnavailableMessage('Voice recording is not supported in this browser. Please use a modern browser like Chrome, Firefox, or Safari.');
        return false;
      } else {
        // MediaDevices exists but getUserMedia might not - let user try
        console.log('MediaDevices available but getUserMedia uncertain - allowing user to try');
      }
    }
    
    // Check server secure context status
    try {
      const response = await fetch('/static/uploads/voice/', { method: 'HEAD' });
      const secureContext = response.headers.get('X-Secure-Context');
      const httpsUpgrade = response.headers.get('X-HTTPS-Upgrade');
      
      // Only hide for HTTP on remote networks, allow local development and HTTPS
      const isLocalhost = window.location.hostname === 'localhost' || 
                         window.location.hostname === '127.0.0.1' || 
                         window.location.hostname.startsWith('192.168.') ||
                         window.location.hostname.startsWith('10.') ||
                         window.location.hostname.endsWith('.local');
      
      const isHttps = window.location.protocol === 'https:';
      
      if (secureContext === 'false' && !isLocalhost && !isHttps) {
        // Only hide for remote HTTP connections
        recordBtn.style.display = 'none';
        infoBtn.style.display = 'inline-block';
        console.warn('Voice recording not available: Requires HTTPS for remote access');
        showVoiceUnavailableMessage(
          'Voice recording requires HTTPS for remote access.',
          httpsUpgrade ? `<br><a href="${httpsUpgrade}" class="btn btn-sm btn-success mt-2">
            <i class="fas fa-lock"></i> Switch to HTTPS
          </a>` : ''
        );
        return false;
      } else {
        console.log('Recording allowed:', { isLocalhost, isHttps, secureContext });
      }
    } catch (error) {
      console.warn('Could not check server security context:', error);
    }
    
    // Check if we're in a secure context (HTTPS or localhost) - but be more permissive
    const isLocalNetwork = window.location.hostname === 'localhost' || 
                           window.location.hostname === '127.0.0.1' ||
                           window.location.hostname.startsWith('192.168.') ||
                           window.location.hostname.startsWith('10.') ||
                           window.location.hostname.endsWith('.local');
    
    if (!window.isSecureContext && !isLocalNetwork) {
      // Only warn for remote HTTP connections, but still allow user to try
      console.warn('Voice recording may have issues: Not in secure context for remote access');
      
      // Show a warning but don't completely block
      showVoiceUnavailableMessage(
        'Voice recording works best with HTTPS. You may experience issues with HTTP.',
        `<br><small>💡 Try: <code>https://${window.location.hostname}${window.location.port ? ':' + window.location.port : ''}</code></small><br>
         <button class="btn btn-sm btn-warning mt-2" onclick="this.parentElement.parentElement.style.display='none';">
           <i class="fas fa-exclamation-triangle"></i> Continue Anyway
         </button>`
      );
      
      // Don't return false - let user continue
    }
    
    // Test if getUserMedia is actually accessible (with permission prompt)
    try {
      // Show initial state while testing
      recordBtn.style.display = 'inline-block';
      recordBtn.disabled = true;
      recordBtn.title = 'Testing microphone access...';
      infoBtn.style.display = 'none';
      
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      // Success - microphone access granted
      stream.getTracks().forEach(track => track.stop()); // Clean up test stream
      recordBtn.disabled = false;
      recordBtn.title = 'Record Voice Message';
      
      // Remove any status messages
      const statusDiv = document.getElementById('voice-status-message');
      if (statusDiv) {
        statusDiv.remove();
      }
      
      console.log('✅ Voice recording available');
      return true;
      
    } catch (error) {
      // Access denied or not available
      recordBtn.style.display = 'none';
      infoBtn.style.display = 'inline-block';
      console.warn('Voice recording not available:', error.message);
      
      if (error.name === 'NotAllowedError') {
        showVoiceUnavailableMessage(
          'Microphone access denied. Please enable microphone permissions in your browser settings.',
          `<br><button class="btn btn-sm btn-info mt-2" onclick="checkVoiceRecordingSupport()">
            <i class="fas fa-redo"></i> Try Again
          </button>`
        );
      } else if (error.name === 'NotFoundError') {
        showVoiceUnavailableMessage('No microphone found. Please connect a microphone and refresh the page.');
      } else if (error.name === 'NotReadableError') {
        showVoiceUnavailableMessage('Microphone is being used by another application. Please close other apps using the microphone.');
      } else {
        showVoiceUnavailableMessage('Voice recording unavailable: ' + error.message);
      }
      return false;
    }
  }
  
  function showVoiceUnavailableMessage(message, additionalContent = '') {
    // Create or update a status message near the record button
    let statusDiv = document.getElementById('voice-status-message');
    if (!statusDiv) {
      statusDiv = document.createElement('div');
      statusDiv.id = 'voice-status-message';
      statusDiv.className = 'alert alert-warning alert-sm mt-2';
      statusDiv.style.fontSize = '0.8em';
      statusDiv.style.padding = '0.5rem';
      
      // Insert after the message input group
      const inputGroup = document.querySelector('.input-group');
      if (inputGroup && inputGroup.parentNode) {
        inputGroup.parentNode.insertBefore(statusDiv, inputGroup.nextSibling);
      }
    }
    
    statusDiv.innerHTML = `
      <i class="fas fa-info-circle"></i> ${message}
      ${additionalContent}
    `;
  }
  
  // Run the check
  checkVoiceRecordingSupport();

  // Add download chat history functionality
  function downloadChatHistory() {
    const downloadBtn = document.getElementById('download-chat-btn');
    const originalText = downloadBtn.innerHTML;
    
    // Show loading state
    downloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Downloading...';
    downloadBtn.disabled = true;
    
    // Download the CSV file
    fetch(`/api/chat/download-history/${otherUserId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`
      }
    })
    .then(response => {
      if (!response.ok) {
        throw new Error('Download failed');
      }
      return response.blob();
    })
    .then(blob => {
      // Create download link
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      
      // Generate filename with timestamp
      const now = new Date();
      const timestamp = now.toISOString().split('T')[0]; // YYYY-MM-DD format
      const otherUserName = '{{ remote_user.full_name or remote_user.email }}'.replace(/[<>"]/g, '');
      a.download = `chat_history_${otherUserName}_${timestamp}.csv`;
      
      // Trigger download
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
      
      // Show success message
      showTemporaryMessage('Chat history downloaded successfully!', 'success');
    })
    .catch(error => {
      console.error('Download error:', error);
      showTemporaryMessage('Failed to download chat history. Please try again.', 'error');
    })
    .finally(() => {
      // Restore button state
      downloadBtn.innerHTML = originalText;
      downloadBtn.disabled = false;
    });
  }
  
  function showTemporaryMessage(message, type = 'info') {
    // Create temporary message element
    const messageDiv = document.createElement('div');
    messageDiv.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} alert-dismissible`;
    messageDiv.style.position = 'fixed';
    messageDiv.style.top = '20px';
    messageDiv.style.right = '20px';
    messageDiv.style.zIndex = '9999';
    messageDiv.style.minWidth = '300px';
    messageDiv.innerHTML = `
      <i class="fas fa-${type === 'error' ? 'exclamation-triangle' : type === 'success' ? 'check-circle' : 'info-circle'}"></i>
      ${message}
      <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
    `;
    
    document.body.appendChild(messageDiv);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (messageDiv.parentElement) {
        messageDiv.remove();
      }
    }, 5000);
  }
  
  // Add event listener for download button
  document.addEventListener('DOMContentLoaded', function() {
    const downloadBtn = document.getElementById('download-chat-btn');
    if (downloadBtn) {
      downloadBtn.addEventListener('click', downloadChatHistory);
    }
  });

})();
</script>

<!-- Chat Summary JavaScript -->
<script src="{{ url_for('static', path='js/chat_summary.js') }}"></script>

<!-- Initialize Chat Summary with Data -->
<script>
// Set global variables for summary functionality
window.remoteUserId = {{ remote_user.id }};
window.userLanguage = '{{ current_user.preferred_language or "en" }}';

// Initialize summary when page loads
document.addEventListener('DOMContentLoaded', function() {
  // Add data attributes to help summary module
  const chatContainer = document.querySelector('.card');
  if (chatContainer) {
    chatContainer.setAttribute('data-other-user-id', '{{ remote_user.id }}');
    chatContainer.setAttribute('data-user-language', '{{ current_user.preferred_language or "en" }}');
  }
});
</script>
{% endblock %}
